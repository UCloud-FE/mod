# 背景

## 前端的各种模块方案

[前端模块简史 - CJS & \*MD & ES Modules & SystemJS & Webpack](https://juejin.cn/post/6844903632198959112)

## 存在的问题

目前前端模块方案基本被打包工具替代，开发者通过 `cjs` 和 `es module` 标准语法，配合打包设置，就可以把模块加载等琐事交给打包工具来处理。

然而在跨项目模块共享方面各打包工具的支持并不理想，并且使用打包工具管理模块的加载很容易因为工具链的升级、互斥而导致各种问题。

以 `webpack` 为例，假设 `a` 项目中存在模块 `a_module_1`，而项目 `b` 想要使用 `a_module_1` 时，可能有以下几种选择：

1. 项目 `a` 和 `b` 都使用 `webpack 5`，然后在 `a` 中通过 `Module Federation` 将模块共享
    - 对现有项目改动成本过高
    - 过于依赖工具链
2. 将模块 `a_module_1` 拆分为独立项目打包发布（`npm` 包或线上包），然后在 `a`、`b` 中使用
    - 需要将 `a_module_1` 拆离，如果耦合性较高会增加后续 `a` 的维护成本
    - `npm` 包方式在偏业务模块时容易导致不同步，线上包方式需要管理 `a` 和 `b` 中相关的模块加载方式，重复加载等可能会出现问题等

无论是哪种方案都可能会对现有项目带来冲击，增加后续维护成本。

## 解决方案

在项目 `a` 中，将 `a_module_1` 通过 `mod.export` 抛出。项目 `a` 打包时，将打包后的信息保存（如在 `webpack` 中通过 `emit hook` 返回的 `compilation`），得到模块的文件信息。

项目 `b` 中，可通过获取 `a` 的模块信息文件，读取 `a` 的文件信息，然后通过 `mod.config` 注册，并使用 `mod.import` 来进行加载。

如此只需在项目 `a` 中进行极少的代码变更即可，并且 `a` 的工具链变化也不会影响（只需在新的工具链中抛出模块信息即可）。

## 为何不用现有模块方案

-   现有方案大部分会对代码造成侵入性改动。
-   模块和项目需要模块与打包进行配合实现。
-   基本都采用类似 `amd` 的方式，声明后置，在加载方面会变为串行，依赖链较长就会导致加载等待过长。
-   模块加载及完成，当模块需要初始化等操作时，对使用方和后续维护成本过高。

## mod 特点

### 文件不相关

`mod` 模块通过调用 `mod.export` 显式进行抛出，可以在任意文件的任意位置对模块进行抛出，或是多文件抛出一个模块、或是一个文件抛出多个模块。

### 工具链不相关

`mod` 对工具链的唯一要求只是需要得到模块对应的文件地址。

### 优化模块加载过程

在模块中可预先声明模块的依赖，此时 `mod` 将会将依赖同步进行加载，极大加快加载速度。

### 模块的自我管理

`mod` 模块的声明周期为 **加载 -> 等待依赖 -> 抛出模块**，除了模块加载，其它部分模块都可自己管理，如某些业务模块，初始化可能会依赖于 `API`，此时可加载 `API` 后再抛出模块，即可让使用方无需对模块进行管理，让模块实现自我管理。

模块在出错时可通过 `mod.throw` 来显式的抛出错误，方便调用方获取错误并进行对应的处理（上报等）。
